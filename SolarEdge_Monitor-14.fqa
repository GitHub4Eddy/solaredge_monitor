{"name":"SolarEdge Monitor","type":"com.fibaro.powerSensor","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_835"},"sections":{"items":[{"components":[{"name":"label1","style":{"weight":"1.2"},"text":"Label","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_835"}}},"uiCallbacks":[],"quickAppVariables":[{"name":"interval","type":"string","value":"360"},{"name":"httpTimeout","type":"string","value":"5"},{"name":"siteID","value":"0"},{"name":"apiKey","value":"0"},{"name":"solarM2","value":"0"},{"name":"debugLevel","value":"1"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"-- QUICKAPP SolarEdge Monitor\n\n-- This QuickApp monitors your SolarEdge managed Solar Panels\n-- The QuickApp has (child) devices for currentPower, lastDayData, lastMonthData, lastYearData and lifeTimeData\n-- The settings for Peak Power and Currency are retrieved from the inverter \n-- The rateType interface of Child device Last Day is automatically set to \"production\" and can be shown in the Energy Panel \n-- The readings for lastmonth, lastyear and lifetime energy are automatically set to the right Wh unit (Wh, kWh, MWh or GWh) \n-- See API documentation on https://www.solaredge.com/sites/default/files/se_monitoring_api.pdf \n\n\n-- Changes version 1.4 (22th February 2022)\n-- Changed rounding of all Wh values to one number after the decimal point, to prevent issues with decreasing values from SolarEdge Cloud\n-- Added extra check for decreasing values from SolarEdge Cloud lastDayData\n-- Changed handling bad responses from SolarEdge Cloud\n-- Removed QuickApp variable icon, icon can be selected in the user interface with the new firmware\n\n\n-- Changes version 1.3 (8th January 2022)\n-- Extra check on return value API for \"Too many requests\"\n\n-- Changes version 1.2 (26th August 2021)\n-- Added values update main device to power interface to show usage in Power consumption chart\n-- Solved a bug in the lifeTimeData.revenue existence check\n\n-- Changes version 1.1 (21th August 2021)\n-- Changed back currentPower measurement to Watt and lastDayData, lastMonthData to kWh (not to mess up statistics in Energy panel or InfluxDB/Grafana installations)\n-- Changed Child device currentPower to Main device with type com.fibaro.powerSensor (Watt). So the Main device will show the current power production, no Child device necessary. \n-- Changed Child device lastDayData to type com.fibaro.energyMeter (kWh). These values will be shown in the new energy panel. \n-- Added automaticaly change rateType interface of Child device lastDayData to \"production\"\n-- Added extra check on apiKey and siteID, if not OK then change to simulation mode\n-- SolarEdge Monitor settings currency and PiekPower also available in simulation mode\n-- Changed the lastUpdateTime to format dd-mm-yyyy hh:mm \n\n-- Changes version 1.0 (30th July 2021)\n-- Total m² solar panels added to log text and label text\n-- Check for API existance of lifeTimeData_revenue (not available in older firmware)\n-- Automatic conversion added for lastmonthData, lastYearData and lifetimeData production to Wh, kWh, MWh or GWh\n-- Automatic conversion added for currentPower to Watt, Kilowatt, Megawatt or Gigawatt (yes, Megawatt and Gigawatt is optimistic)\n-- Get the Peakpower and Currency settings from Inverter\n-- Peakpower added to label text and child device log text\n\n-- Changes version 0.3 (12th April 2021)\n-- Added last update date / time\n-- Cleaned up the code\n\n-- Changes version 0.2 (12th April 2021)\n-- Disabled revenue value (except for lifeTimeData)\n\n-- Changes version 0.1 (11th April 2021)\n-- First (test) version\n\n\n-- Variables (mandatory): \n-- siteID = Site ID of your SolarEdge Inverter (see your Inverter Site Details)\n-- apiKey = API key of your SolarEdge Inverter (contact your installer if you don't have one)\n-- solarM2 = The amount of m2 Solar Panels (use . for decimals) for calculating Solar Power m2 (default = 0)\n-- interval = The daily API limitation is 300 requests. The default request interval is 360 seconds (6 minutes).\n-- debugLevel = Number (1=some, 2=few, 3=all, 4=simulation mode) (default = 1)\n\n\n-- Example json overview string from API documentation:\n-- {\"overview\": {\"lastUpdateTime\": \"2021-03-01 02:37:47\",\"lifeTimeData\": {\"energy\": 761985.75,\"revenue\": 946.13104},\"lastYearData\": {\"energy\": 761985.8,\"revenue\": 946.13104},\"lastMonthData\": {\"energy\": 492736.7,\"revenue\": 612.09528},\"lastDayData\": {\"energy\": 1327.3,\"revenue\": 1.64844},\"currentPower\": {\"power\": 304.8}}}\n\n-- Example json overview string from SolarEdge response:\n-- {\"overview\":{\"lastUpdateTime\":\"2021-04-12 13:46:04\",\"lifeTimeData\":{\"energy\":7827878.0,\"revenue\":1728.5211},\"lastYearData\":{\"energy\":573242.0},\"lastMonthData\":{\"energy\":113386.0},\"lastDayData\":{\"energy\":7373.0},\"currentPower\":{\"power\":134.73499},\"measuredBy\":\"INVERTER\"}}\n\n\n-- No editing of this code is needed \n\n\nclass 'solarPower'(QuickAppChild)\nfunction solarPower:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction solarPower:updateValue(data) \n  self:updateProperty(\"value\", tonumber(data.solarPower))\n  self:updateProperty(\"unit\", \"Watt/m²\")\n  self:updateProperty(\"log\", details.peakPower ..\" kWp / \" ..solarM2 ..\" m²\")\nend\n\nclass 'lastDayData'(QuickAppChild)\nfunction lastDayData:__init(dev)\n  QuickAppChild.__init(self,dev)\n  if fibaro.getValue(self.id, \"rateType\") ~= \"production\" then \n    self:updateProperty(\"rateType\", \"production\")\n  self:warning(\"Changed rateType interface of SolarEdge lastDayData child device (\" ..self.id ..\") to production\")\n  end\nend\nfunction lastDayData:updateValue(data) \n  self:updateProperty(\"value\", tonumber(data.lastDayData))\n  self:updateProperty(\"unit\", \"kWh\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'lastMonthData'(QuickAppChild)\nfunction lastMonthData:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction lastMonthData:updateValue(data) \n  self:updateProperty(\"value\", tonumber(data.lastMonthData))\n  self:updateProperty(\"unit\", \"kWh\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'lastYearData'(QuickAppChild)\nfunction lastYearData:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction lastYearData:updateValue(data) \n  self:updateProperty(\"value\", tonumber(data.lastYearData))\n  self:updateProperty(\"unit\", data.lastYearUnit)\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'lifeTimeData'(QuickAppChild)\nfunction lifeTimeData:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction lifeTimeData:updateValue(data) \n  self:updateProperty(\"value\", tonumber(data.lifeTimeData))\n  self:updateProperty(\"unit\", data.lifeTimeUnit)\n  self:updateProperty(\"log\", data.lifeTimeData_revenue)\nend\n\n\nlocal function getChildVariable(child,varName)\n  for _,v in ipairs(child.properties.quickAppVariables or {}) do\n    if v.name==varName then return v.value end\n  end\n  return \"\"\nend\n\n\n-- QuickApp functions\n\n\nfunction QuickApp:logging(level,text) -- Logging function for debug\n  if tonumber(debugLevel) >= tonumber(level) then \n      self:debug(text)\n  end\nend\n\n\nfunction QuickApp:solarPower(power, m2) -- Calculate Solar Power M2\n  self:logging(3,\"Start solarPower\")\n  if m2 > 0 and power > 0 then\n    solarPower = power / m2\n  else\n    solarPower = 0\n  end\n  return solarPower\nend\n\n\nfunction QuickApp:unitCheckWh(measurement) -- Set the measurement and unit to kWh, MWh or GWh\n  self:logging(3,\"Start unitCheckWh\")\n  if measurement > 1000000000 then\n    return string.format(\"%.1f\",measurement/1000000000),\"GWh\"\n  elseif measurement > 1000000 then\n    return string.format(\"%.1f\",measurement/1000000),\"MWh\"\n  elseif measurement > 1000 then\n    return string.format(\"%.1f\",measurement/1000),\"kWh\"\n  else\n    return string.format(\"%.0f\",measurement),\"Wh\"\n  end\nend\n\n\nfunction QuickApp:updateProperties() -- Update the properties\n  self:logging(3,\"updateProperties\")\n  self:updateProperty(\"value\", tonumber(data.currentPower))\n  self:updateProperty(\"power\", tonumber(data.currentPower))\n  self:updateProperty(\"unit\", \"Watt\")\n  self:updateProperty(\"log\", data.lastUpdateTime)\nend\n\n\nfunction QuickApp:updateLabels() -- Update the labels\n  self:logging(3,\"updateLabels\")\n  local labelText = \"\"\n  if debugLevel == 4 then\n    labelText = labelText ..\"SIMULATION MODE\" ..\"\\n\\n\"\n  end\n  labelText = labelText ..\"Current power: \" ..data.currentPower ..\" Watt\" ..\"\\n\\n\"\n  labelText = labelText ..\"Peakpower: \" ..details.peakPower ..\" kWp\" ..\"\\n\"\n  labelText = labelText ..\"Solar power: \" ..data.solarPower ..\" Watt/m² (\" ..solarM2 ..\" m²)\" ..\"\\n\"\n  labelText = labelText ..\"Lastday: \" ..data.lastDayData ..\" kWh\" ..\"\\n\"\n  labelText = labelText ..\"Lastmonth: \" ..data.lastMonthData ..\" kWh\" ..\"\\n\"\n  labelText = labelText ..\"Lastyear: \" ..data.lastYearData ..\" \" ..data.lastYearUnit ..\"\\n\"\n  labelText = labelText ..\"Lifetime: \" ..data.lifeTimeData ..\" \" ..data.lifeTimeUnit ..\" (\" ..data.lifeTimeData_revenue ..\")\" ..\"\\n\\n\"\n  labelText = labelText ..\"Last update: \" ..data.lastUpdateTime ..\"\\n\" \n  self:updateView(\"label1\", \"text\", labelText)\n  self:logging(2,labelText)\nend\n\n\nfunction QuickApp:valuesCheck() -- Check of Cloud value lastDayData\n  self:logging(3,\"valuesCheck\")\n  self:logging(2,\"Previous lastDayData: \" ..data.prevlastDayData .. \" / Next lastDayData: \" ..data.lastDayData)\n  local templastDayData = data.lastDayData -- Save lastDayData\n  if tonumber(data.prevlastDayData) ~= 0 and tonumber(data.lastDayData) ~= 0 and (tonumber(data.lastDayData) < tonumber(data.prevlastDayData)) then -- Check previous value with next value \n    self:trace(\"Decreasing value lastDayData ignored (Energy Panel Child Device), previous value: \" ..data.prevlastDayData ..\" next value: \" ..data.lastDayData)\n    data.lastDayData = string.format(\"%.1f\", data.prevlastDayData) -- Restore previous lastDayData value\n  end\n  data.prevlastDayData = string.format(\"%.1f\", templastDayData) -- Save lastDayData to \nend\n\n\nfunction QuickApp:valuesOverview() -- Get the values from json file Overview\n  self:logging(3,\"valuesOverview\")\n  data.currentPower = string.format(\"%.0f\", jsonTable.overview.currentPower.power)\n  data.solarPower = string.format(\"%.1f\",self:solarPower(tonumber(data.currentPower), tonumber(solarM2)))\n  data.lastDayData = string.format(\"%.1f\",jsonTable.overview.lastDayData.energy/1000)\n  data.lastMonthData = string.format(\"%.1f\",jsonTable.overview.lastMonthData.energy/1000)\n  data.lastYearData = jsonTable.overview.lastYearData.energy\n  data.lastYearData, data.lastYearUnit = self:unitCheckWh(tonumber(data.lastYearData)) -- Set measurement and unit to kWh, MWh or GWh\n  data.lifeTimeData = jsonTable.overview.lifeTimeData.energy\n  data.lifeTimeData, data.lifeTimeUnit = self:unitCheckWh(tonumber(data.lifeTimeData)) -- Set measurement and unit to kWh, MWh or GWh\n  if jsonTable.overview.lifeTimeData.revenue ~= nil then -- lifeTimeData_revenue is not mandatory\n    data.lifeTimeData_revenue = string.format(\"%.2f\", jsonTable.overview.lifeTimeData.revenue) ..\" \" ..details.currency\n  end\n  data.lastUpdateTime = jsonTable.overview.lastUpdateTime\n  local pattern = \"(%d+)-(%d+)-(%d+) (%d+):(%d+):(%d+)\"\n  local runyear, runmonth, runday, runhour, runminute, runseconds = data.lastUpdateTime:match(pattern)\n  local convertedTimestamp = os.time({year = runyear, month = runmonth, day = runday, hour = runhour, min = runminute, sec = runseconds})\n  data.lastUpdateTime = os.date(\"%d-%m-%Y %H:%M\", convertedTimestamp)\n  \n  self:valuesCheck() -- Temporarily check of Cloud values\n  \nend\n\n\nfunction QuickApp:valuesDetails() -- Get the values from json file Details\n  self:logging(3,\"valuesDetails\")\n  if details.peakPower ~= nil then -- details.peakPower is not mandatory\n    details.peakPower = string.format(\"%.1f\", jsonTableDetails.details.peakPower)\n  end\n  if details.currency ~= nil then -- details.currency is not mandatory\n    details.currency = jsonTableDetails.details.currency\n  end\nend\n\n\nfunction QuickApp:simData() -- Simulate SolarEdge Monitor\n  self:logging(3,\"simData\")\n  apiResult = '{\"overview\":{\"lastUpdateTime\":\"2021-08-12 13:46:04\",\"lifeTimeData\":{\"energy\":7827878.0,\"revenue\":1728.5211},\"lastYearData\":{\"energy\":573242.0},\"lastMonthData\":{\"energy\":113386.0},\"lastDayData\":{\"energy\":7373.0},\"currentPower\":{\"power\":134.73499},\"measuredBy\":\"INVERTER\"}}' -- With revenue\n  --apiResult = '{\"overview\":{\"lastUpdateTime\":\"2021-08-26 10:58:29\",\"lifeTimeData\":{\"energy\":1.6099509E7},\"lastYearData\":{\"energy\":6773922.0},\"lastMonthData\":{\"energy\":836428.0},\"lastDayData\":{\"energy\":4276.0},\"currentPower\":{\"power\":2206.0},\"measuredBy\":\"INVERTER\"}}' -- Without revenue\n \n  jsonTable = json.decode(apiResult) -- Decode the json string from api to lua-table \n  \n  self:valuesOverview()\n  self:updateLabels()\n  self:updateProperties()\n\n  for id,child in pairs(self.childDevices) do \n    child:updateValue(data,userID) \n  end\n  \n  self:logging(3,\"SetTimeout \" ..interval ..\" seconds\")\n  fibaro.setTimeout(interval*1000, function() \n     self:simData()\n  end)\nend\n\n\nfunction QuickApp:getData() -- Get the data from the API\n  self:logging(3,\"getData\")\n  self:logging(2,\"URL Overview: \" ..urlOverview)\n  http:request(urlOverview, {\n    options={headers = {Accept = \"application/json\"},method = 'GET'},   \n      success = function(response)\n        self:logging(3,\"response status: \" ..response.status)\n        self:logging(3,\"headers: \" ..response.headers[\"Content-Type\"])\n        self:logging(2,\"Response data: \" ..response.data)\n\n        if response.data == nil or response.data == \"\" or response.data == \"[]\" or response.status > 200 then -- Check for empty result\n          self:warning(\"Temporarily no production data from SolarEdge Monitor\")\n          return\n        end\n        \n        jsonTable = json.decode(response.data) -- JSON decode from api to lua-table\n\n        self:valuesOverview()\n        self:updateLabels()\n        self:updateProperties()\n\n        for id,child in pairs(self.childDevices) do \n          child:updateValue(data,userID) \n        end\n\n      end,\n      error = function(error)\n        self:error(\"error: \" ..json.encode(error))\n        self:updateProperty(\"log\", \"error: \" ..json.encode(error))\n      end\n    }) \n  \n  self:logging(3,\"SetTimeout \" ..interval ..\" seconds\")\n  fibaro.setTimeout(interval*1000, function() \n     self:getData()\n  end)\nend\n\n\nfunction QuickApp:simDetails() -- Simulate Details SolarEdge Monitor\n  self:logging(3,\"simDetails\")\n  details.peakPower = \"4.5\" -- PiekWatt in kWp\n  details.currency = \"EUR\" -- Standard Euro currency\nend\n\n\nfunction QuickApp:getDetails() -- Get the settings from the API\n  self:logging(3,\"getDetails\")\n  self:logging(2,\"URL Details: \" ..urlDetails)\n  http:request(urlDetails, {\n    options={headers = {Accept = \"application/json\"},method = 'GET'},   \n      success = function(response)\n        self:logging(3,\"response status: \" ..response.status)\n        self:logging(3,\"headers: \" ..response.headers[\"Content-Type\"])\n        self:logging(2,\"Response data: \" ..response.data)\n\n        if response.data == nil or response.data == \"\" or response.data == \"[]\" then -- Check for empty result\n          self:warning(\"Temporarily no details data from SolarEdge Monitor\")\n          return\n        end\n\n        jsonTableDetails = json.decode(response.data) -- JSON decode from api to lua-table\n\n        self:valuesDetails()\n\n      end,\n      error = function(error)\n        self:error(\"error: \" ..json.encode(error))\n        self:updateProperty(\"log\", \"error: \" ..json.encode(error))\n      end\n    }) \nend\n\n\nfunction QuickApp:createVariables() -- Create all Variables \n  jsonTable = {}\n  jsonTableDetails = {}\n  details = {}\n  details.peakPower = \"0\"\n  details.currency = \"EUR\"\n  data = {}\n  data.currentPower = \"0\"\n  data.solarPower = \"0\" \n  data.lastDayData = \"0\"\n  data.prevlastDayData = \"0\"\n  data.lastMonthData = \"0\"\n  data.lastYearData= \"0\"\n  data.lastYearUnit= \"Wh\"\n  data.lifeTimeData= \"0\"\n  data.lifeTimeUnit= \"Wh\"\n  data.lifeTimeData_revenue = \"0\"\n  data.lastUpdateTime = \"\"\nend\n\n\nfunction QuickApp:getQuickAppVariables() -- Get all Quickapp Variables or create them\n  local siteID = self:getVariable(\"siteID\")\n  local apiKey = self:getVariable(\"apiKey\")\n  solarM2 = tonumber(self:getVariable(\"solarM2\"))\n  interval = tonumber(self:getVariable(\"interval\")) \n  httpTimeout = tonumber(self:getVariable(\"httpTimeout\")) \n  debugLevel = tonumber(self:getVariable(\"debugLevel\"))\n\n  -- Check existence of the mandatory variables, if not, create them with default values\n  if siteID == \"\" or siteID == nil then\n    siteID = \"0\" -- This siteID is just an example, it is not working \n    self:setVariable(\"siteID\",siteID)\n    self:trace(\"Added QuickApp variable siteID\")\n  end\n if apiKey == \"\" or apiKey == nil then\n    apiKey = \"0\" -- This API key is just an example, it is not working\n    self:setVariable(\"apiKey\",apiKey)\n    self:trace(\"Added QuickApp variable apiKey\")\n  end \n  if solarM2 == \"\" or solarM2 == nil then \n    solarM2 = \"0\" \n    self:setVariable(\"solarM2\",solarM2)\n    self:trace(\"Added QuickApp variable solarM2\")\n  end \n  if interval == \"\" or interval == nil then\n    interval = \"360\" -- The default interval is 6 minutes (360 seconds) \n    self:setVariable(\"interval\",interval)\n    self:trace(\"Added QuickApp variable interval\")\n    interval = tonumber(interval)\n  end\n  if httpTimeout == \"\" or httpTimeout == nil then\n    httpTimeout = \"5\" -- Default http timeout \n    self:setVariable(\"httpTimeout\",httpTimeout)\n    self:trace(\"Added QuickApp variable httpTimeout\")\n    httpTimeout = tonumber(httpTimeout)\n  end \n  if debugLevel == \"\" or debugLevel == nil then\n    debugLevel = \"1\" -- Default debug level\n    self:setVariable(\"debugLevel\",debugLevel)\n    self:trace(\"Added QuickApp variable debugLevel\")\n    debugLevel = tonumber(debugLevel)\n  end\n  if apiKey == nil or apiKey == \"\"  or apiKey == \"0\" then -- Check mandatory apiKey \n    self:error(\"API key is empty! Get your API key from your installer and copy the apiKey to the quickapp variable\")\n    self:warning(\"No API Key: Switched to Simulation Mode\")\n    debugLevel = 4 -- Simulation mode due to empty apiKey\n  end\n  if siteID == nil or siteID == \"\"  or siteID == \"0\" then -- Check mandatory siteID   \n    self:error(\"Site ID is empty! Get your siteID key from your inverter and copy the siteID to the quickapp variable\")\n    self:warning(\"No siteID: Switched to Simulation Mode\")\n    debugLevel = 4 -- Simulation mode due to empty siteID \n  end\n  \n  urlOverview = \"https://monitoringapi.solaredge.com/site/\"..siteID ..\"/overview.json?api_key=\"..apiKey\n  urlDetails = \"https://monitoringapi.solaredge.com/site/\"..siteID ..\"/details?api_key=\"..apiKey\nend\n\n\nfunction QuickApp:setupChildDevices()\n  local cdevs = api.get(\"/devices?parentId=\"..self.id) or {} -- Pick up all Child Devices\n  function self:initChildDevices() end -- Null function, else Fibaro calls it after onInit()...\n\n  if #cdevs == 0 then -- If no Child Devices, create them\n      local initChildData = { \n        {className=\"solarPower\", name=\"Solar Power\", type=\"com.fibaro.powerSensor\", value=0},\n        {className=\"lastDayData\", name=\"Last day\", type=\"com.fibaro.energyMeter\", value=0},\n        {className=\"lastMonthData\", name=\"Last month\", type=\"com.fibaro.multilevelSensor\", value=0},\n        {className=\"lastYearData\", name=\"Last year\", type=\"com.fibaro.multilevelSensor\", value=0},\n        {className=\"lifeTimeData\", name=\"Lifetime\", type=\"com.fibaro.multilevelSensor\", value=0},\n      }\n    for _,c in ipairs(initChildData) do\n      local child = self:createChildDevice(\n        {name = c.name,\n          type=c.type,\n          value=c.value,\n          unit=c.unit,\n          initialInterfaces = {},\n        },\n        _G[c.className] -- Fetch class constructor from class name\n      )\n      child:setVariable(\"className\",c.className)  -- Save class name so we know when we load it next time\n    end   \n  else \n    for _,child in ipairs(cdevs) do\n      local className = getChildVariable(child,\"className\") -- Fetch child class name\n      local childObject = _G[className](child) -- Create child object from the constructor name\n      self.childDevices[child.id]=childObject\n      childObject.parent = self -- Setup parent link to device controller \n    end\n  end\nend\n\n\nfunction QuickApp:onInit()\n  __TAG = fibaro.getName(plugin.mainDeviceId) ..\" ID:\" ..plugin.mainDeviceId\n  self:debug(\"onInit\") \n  \n  self:setupChildDevices()\n  \n  if not api.get(\"/devices/\"..self.id).enabled then\n    self:warning(\"Device\", fibaro.getName(plugin.mainDeviceId), \"is disabled\")\n    return\n  end\n  \n  self:getQuickAppVariables() \n  self:createVariables()\n  \n  http = net.HTTPClient({timeout=httpTimeout*1000})\n  \n  \n  if tonumber(debugLevel) >= 4 then \n    self:simDetails() -- Set settings to standard values\n    self:simData() -- Go in simulation\n  else\n    self:getDetails() -- Get settings from SolarEdge Monitor\n    self:getData() -- Get data from SolarEdge Monitor\n  end\nend\n\n-- EOF  "}]}